# IMPORTANT: This file is generated by cucumber-rails - edit at your own peril.
# It is recommended to regenerate this file in the future when you upgrade to a
# newer version of cucumber-rails. Consider adding your own code to a new file
# instead of editing this one. Cucumber will automatically load all features/**/*.rb
# files.
ENV['HONEYBADGER_ENV'] = 'test'

if ENV['RUN_NIGHTLY_BUILD']
  require 'simplecov'
  require 'capybara-screenshot/cucumber'
  Capybara::Screenshot.autosave_on_failure = false
end

require 'cucumber/rails'
require 'factory_girl_rails'
require 'capybara/cucumber'
require 'capybara/rspec'
require 'rspec/expectations'

Capybara.register_driver :chrome do |app|
  client = Selenium::WebDriver::Remote::Http::Default.new
  client.timeout = 120
  Capybara::Selenium::Driver.new app, browser: :chrome, http_client: client
end

Capybara.register_driver :webkit do |app|
  # Overrides Capybara's registration of the webkit driver. We do this so that we can pass along the
  # :resynchronize symbol, which tells Capybara to wait until all ajax call have completed before continuing on
  # to the next test.
  Capybara::Webkit::Driver.new app, resynchronize: true
end

Capybara.javascript_driver = Capybara.default_driver = ENV.fetch('TEST_DRIVER'){ 'chrome' }.to_sym

# Capybara defaults to CSS3 selectors rather than XPath.
# If you'd prefer to use XPath, just uncomment this line and adjust any
# selectors in your step definitions to use the XPath syntax.
Capybara.default_selector = :css

# Attempt to set default wait time for Capybara...
Capybara.default_max_wait_time = 60

Capybara.ignore_hidden_elements = true

# TODO: find a better way to config
Capybara.app_host = "http://app.lvh.me:31337"
Capybara.server_host = "app.lvh.me"
Capybara.server_port = "31337"
Rails.application.routes.default_url_options[:port]= 31337
# ResqueSpec.inline = Resque.inline = false

Capybara.run_server = false if (ENV['server'].to_s.downcase == "no")

# By default, any exception happening in your Rails application will bubble up
# to Cucumber so that your scenario will fail. This is a different from how
# your application behaves in the production environment, where an error page will
# be rendered instead.
#
# Sometimes we want to override this default behaviour and allow Rails to rescue
# exceptions and display an error page (just like when the app is running in production).
# Typical scenarios where you want to do this is when you test your error pages.
# There are two ways to allow Rails to rescue exceptions:
#
# 1) Tag your scenario (or feature) with @allow-rescue
#
# 2) Set the value below to true. Beware that doing this globally is not
# recommended as it will mask a lot of errors for you!
#
# At this time, it seems like setting this to true is the only way to stop the ActiveRecord::RecordNotFound (ActiveRecord::RecordNotFound)
# errors from killing out build.
ActionController::Base.allow_rescue = true


# Possible values are :truncation and :transaction
# The :transaction strategy is faster, but might give you threading problems.
# See https://github.com/cucumber/cucumber-rails/blob/master/features/choose_javascript_database_strategy.feature
table_exclusions = %w(roles)
DatabaseCleaner.strategy = :truncation, {:except => table_exclusions}

Before do
  DatabaseCleaner.strategy = :truncation, {:except => table_exclusions}
  $do_before_all ||= false
  unless $do_before_all
    $do_before_all = true
    DatabaseCleaner.clean_with :truncation
    Rails.application.load_seed
  end

  begin
    page.current_window.resize_to(1280, 1024)
  rescue
    puts "Can't resize the current window"
  end

end

passed = false
After do |scenario|
  DatabaseCleaner.clean
  passed = scenario.passed?
  if scenario.failed?
    #log_js_error
    #if ENV['RUN_NIGHTLY_BUILD']
    page.save_screenshot "#{ENV['CIRCLE_TEST_REPORTS']}/cucumber/#{DateTime.now.to_i}-#{scenario.name.parameterize}.png"
  end
end

World(FactoryGirl::Syntax::Methods)

# List top slowest-running scenarios
scenario_times = {}

Around do |scenario, block|
  start_time = Time.now
  block.call
  block.call(true) if (!passed && ENV['CI'] == 'true')
  end_time = Time.now

  if scenario.is_a?(Cucumber::Formatter::LegacyApi::Ast::LegacyTableRow)
    thing = scenario.scenario_outline
  else
    thing = scenario
  end
  running_time = end_time.send(:-,  start_time)
  scenario_times["#{thing.feature.file} #{thing.name}"] = running_time
end

at_exit do
  max_scenarios = scenario_times.size > 20 ? 20 : scenario_times.size
  puts "------------- Top #{max_scenarios} slowest scenarios (s) -------------"
  sorted_times = scenario_times.sort { |a, b| b[1] <=> a[1] }
  sorted_times[0..max_scenarios - 1].each do |key, value|
    puts "#{value.round(2)}  #{key}"
  end
  exit 0 if ENV['FORCE_PASS']
end

# Measure step running time on local
#
unless ENV['CI']
  AfterStep do
    @start_time ||= Time.current
    @end_time = Time.current
    puts "Step running time: #{(@end_time - @start_time).round(2)}"
    @start_time = @end_time
  end
end

def log_js_error
  errors = page.driver.browser.manage.logs.get(:browser)
               .select {|e| e.level == "SEVERE" && e.message.present? }
               .map(&:message)
               .to_a

  if errors.present?
    message = <<-EOS

    -------------------------------------------------
    Found #{errors.length} JavaScript errors:
    #{errors.join("\n")}
    -------------------------------------------------
    EOS

    Rails.logger.error(message)
  end
end
